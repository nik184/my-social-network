<!DOCTYPE html>
<html>
<head>
    <title>Distributed Social Network</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background-color: #f5f5f5; }
        .container { max-width: 800px; margin: 0 auto; background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .header { text-align: center; color: #333; margin-bottom: 30px; }
        .section { margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 5px; }
        .button { background-color: #007bff; color: white; padding: 10px 15px; border: none; border-radius: 5px; cursor: pointer; margin: 5px; }
        .button:hover { background-color: #0056b3; }
        .input { padding: 8px; margin: 5px; border: 1px solid #ddd; border-radius: 3px; width: 200px; }
        .result { background-color: #f8f9fa; padding: 10px; margin: 10px 0; border-radius: 3px; font-family: monospace; white-space: pre-wrap; }
        .status { padding: 10px; margin: 10px 0; border-radius: 3px; }
        .success { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .error { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üåê Distributed Social Network</h1>
            <p>Manage and share your space184 directory using libp2p peer-to-peer networking</p>
            <p style="font-size: 0.9em; color: #666;">‚ú® Features: DHT discovery, NAT traversal, hole punching, auto file monitoring</p>
        </div>
        
        <div class="section">
            <h3>üìÅ Directory Management</h3>
            <button class="button" onclick="createDirectory()">Create space184 Directory</button>
            <button class="button" onclick="scanDirectory()">Manual Scan</button>
            <button class="button" onclick="getMonitorStatus()">Monitor Status</button>
            <div id="directoryStatus"></div>
            <div id="monitorStatus" class="status" style="margin: 10px 0;"></div>
            <div id="directoryInfo" class="result"></div>
        </div>
        
        <div class="section">
            <h3>üîç P2P Network Discovery</h3>
            <div style="margin-bottom: 15px;">
                <h4>üîó Connect by Peer ID (Local Network)</h4>
                <input type="text" id="peerIdInput" class="input" placeholder="Enter Peer ID" style="width: 400px;">
                <button class="button" onclick="discoverPeer()">Discover Peer</button>
            </div>
            <div style="margin-bottom: 15px;">
                <h4>üåê Connect by IP Address (Internet)</h4>
                <input type="text" id="ipInput" class="input" placeholder="IP Address (e.g., 203.0.113.1)" style="width: 150px;">
                <input type="text" id="portInput" class="input" placeholder="Port (e.g., 9001)" style="width: 100px;">
                <input type="text" id="targetPeerIdInput" class="input" placeholder="Target Peer ID" style="width: 300px;">
                <button class="button" onclick="connectByIP()">Connect by IP</button>
            </div>
            <div style="margin-bottom: 15px;">
                <h4>üìã Connection String</h4>
                <input type="text" id="connectionStringInput" class="input" placeholder="Paste connection string (IP:PORT:PEER_ID)" style="width: 500px;">
                <button class="button" onclick="connectByString()">Connect</button>
            </div>
            <button class="button" onclick="getConnectedPeers()">Show Connected Peers</button>
            <button class="button" onclick="getConnectionInfo()">Get My Connection Info</button>
            <div id="discoveryStatus"></div>
            <div id="discoveryResult" class="result"></div>
        </div>
        
        <div class="section">
            <h3>‚ÑπÔ∏è Current Node Info</h3>
            <button class="button" onclick="getNodeInfo()">Refresh Info</button>
            <div id="natStatus" class="status" style="margin: 10px 0;"></div>
            <div id="nodeInfo" class="result"></div>
        </div>
        
        <div class="section">
            <h3>üë• Connected Peer Details</h3>
            <button class="button" onclick="getDetailedPeerInfo()">Show Detailed Peer Info</button>
            <div id="peerInfoStatus" class="status" style="margin: 10px 0;"></div>
            <div id="detailedPeerInfo" class="result"></div>
        </div>
    </div>

    <script>
        function showStatus(elementId, message, isError = false) {
            const element = document.getElementById(elementId);
            element.innerHTML = message;
            element.className = 'status ' + (isError ? 'error' : 'success');
        }

        function showResult(elementId, data) {
            document.getElementById(elementId).textContent = JSON.stringify(data, null, 2);
        }

        async function createDirectory() {
            try {
                const response = await fetch('/api/create', { method: 'POST' });
                const data = await response.json();
                showStatus('directoryStatus', 'Directory created successfully!');
            } catch (error) {
                showStatus('directoryStatus', 'Error creating directory: ' + error.message, true);
            }
        }

        async function scanDirectory() {
            try {
                const response = await fetch('/api/scan', { method: 'POST' });
                const data = await response.json();
                showStatus('directoryStatus', 'Manual scan completed successfully!');
                getNodeInfo(); // Refresh the info
            } catch (error) {
                showStatus('directoryStatus', 'Error scanning directory: ' + error.message, true);
            }
        }

        async function getMonitorStatus() {
            try {
                const response = await fetch('/api/monitor');
                const data = await response.json();
                
                if (data.monitoring) {
                    const lastScan = data.lastScan ? new Date(data.lastScan).toLocaleTimeString() : 'Never';
                    showStatus('monitorStatus', `üì° Auto-monitoring active | Last scan: ${lastScan}`, false);
                } else {
                    showStatus('monitorStatus', '‚ùå Auto-monitoring inactive', true);
                }
            } catch (error) {
                showStatus('monitorStatus', 'Error getting monitor status: ' + error.message, true);
            }
        }

        async function discoverPeer() {
            const peerId = document.getElementById('peerIdInput').value;
            if (!peerId) {
                showStatus('discoveryStatus', 'Please enter a Peer ID', true);
                return;
            }

            try {
                const response = await fetch('/api/discover', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ peerId: peerId })
                });
                
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                
                const data = await response.json();
                showStatus('discoveryStatus', 'Peer discovered successfully!');
                showResult('discoveryResult', data);
            } catch (error) {
                showStatus('discoveryStatus', 'Error discovering peer: ' + error.message, true);
                document.getElementById('discoveryResult').textContent = '';
            }
        }

        async function getConnectedPeers() {
            try {
                const response = await fetch('/api/peers');
                const data = await response.json();
                
                const validatedCount = data.validatedCount || data.count || 0;
                const totalCount = data.totalConnectedCount || 0;
                
                if (totalCount > validatedCount) {
                    showStatus('discoveryStatus', `‚úÖ ${validatedCount} app peers | üîó ${totalCount} total connections`, false);
                } else {
                    showStatus('discoveryStatus', `‚úÖ Connected to ${validatedCount} app peers`, false);
                }
                
                // Show detailed information
                const peerInfo = {
                    'Application Peers (Validated)': data.validatedPeers || data.peers || [],
                    'Validated Count': validatedCount,
                    'Total Connections': totalCount,
                    'Filtering': totalCount > validatedCount ? 'Active - Non-app peers filtered out' : 'No non-app peers detected'
                };
                
                showResult('discoveryResult', peerInfo);
            } catch (error) {
                showStatus('discoveryStatus', 'Error getting peers: ' + error.message, true);
            }
        }

        async function getNodeInfo() {
            try {
                const response = await fetch('/api/info');
                const data = await response.json();
                
                // Display NAT status
                if (data.isPublicNode !== undefined) {
                    const natStatusMsg = data.isPublicNode 
                        ? 'üåê PUBLIC NODE - Can assist with NAT traversal' 
                        : 'üè† NAT\'d NODE - Seeks assistance for connections';
                    showStatus('natStatus', natStatusMsg, !data.isPublicNode);
                }
                
                // Create a clean display object
                const displayData = {
                    'Node ID': data.node?.id || 'Unknown',
                    'Addresses': data.node?.addresses || [],
                    'Last Seen': data.node?.lastSeen ? new Date(data.node.lastSeen).toLocaleString() : 'Unknown',
                    'NAT Status': data.isPublicNode ? 'Public (Can help others)' : 'Behind NAT (Needs assistance)',
                    'Directory Info': data.folderInfo || 'No directory scanned yet',
                    'Connected Peers': data.connectedPeerInfo ? Object.keys(data.connectedPeerInfo).length : 0
                };
                
                showResult('nodeInfo', displayData);
            } catch (error) {
                showStatus('nodeInfo', 'Error getting node info: ' + error.message, true);
            }
        }

        async function connectByIP() {
            const ip = document.getElementById('ipInput').value;
            const port = document.getElementById('portInput').value;
            const peerId = document.getElementById('targetPeerIdInput').value;
            
            if (!ip || !port || !peerId) {
                showStatus('discoveryStatus', 'Please enter IP address, port, and peer ID', true);
                return;
            }

            try {
                const response = await fetch('/api/connect-ip', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        ip: ip,
                        port: parseInt(port),
                        peerId: peerId 
                    })
                });
                
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                
                const data = await response.json();
                showStatus('discoveryStatus', 'Successfully connected via IP address!');
                showResult('discoveryResult', data);
            } catch (error) {
                showStatus('discoveryStatus', 'Error connecting by IP: ' + error.message, true);
                document.getElementById('discoveryResult').textContent = '';
            }
        }

        async function connectByString() {
            const connectionString = document.getElementById('connectionStringInput').value;
            
            if (!connectionString) {
                showStatus('discoveryStatus', 'Please enter a connection string', true);
                return;
            }

            // Parse connection string (format: IP:PORT:PEER_ID)
            const parts = connectionString.split(':');
            if (parts.length < 3) {
                showStatus('discoveryStatus', 'Invalid connection string format. Use IP:PORT:PEER_ID', true);
                return;
            }

            const ip = parts[0];
            const port = parts[1];
            const peerId = parts.slice(2).join(':'); // In case peer ID contains colons

            try {
                const response = await fetch('/api/connect-ip', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        ip: ip,
                        port: parseInt(port),
                        peerId: peerId 
                    })
                });
                
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                
                const data = await response.json();
                showStatus('discoveryStatus', 'Successfully connected using connection string!');
                showResult('discoveryResult', data);
            } catch (error) {
                showStatus('discoveryStatus', 'Error connecting by string: ' + error.message, true);
                document.getElementById('discoveryResult').textContent = '';
            }
        }

        async function getConnectionInfo() {
            try {
                const response = await fetch('/api/connection-info');
                const data = await response.json();
                
                // Create a shareable connection string
                let connectionString = '';
                let publicAddress = '';
                
                if (data.publicAddress && data.port && data.peerId) {
                    connectionString = `${data.publicAddress}:${data.port}:${data.peerId}`;
                    publicAddress = `${data.publicAddress}:${data.port}`;
                }
                
                // Extract P2P port from local addresses
                let p2pPort = 'Unknown';
                let localIP = 'Unknown';
                if (data.localAddresses && data.localAddresses.length > 0) {
                    for (const addr of data.localAddresses) {
                        if (addr.includes('/ip4/') && !addr.includes('127.0.0.1')) {
                            const parts = addr.split('/');
                            if (parts.length >= 5) {
                                localIP = parts[2];
                                p2pPort = parts[4];
                                break;
                            }
                        }
                    }
                }

                const connectionInfo = {
                    'Peer ID': data.peerId || 'Unknown',
                    'P2P Port': p2pPort + ' (Use this port for connections!)',
                    'Local IP': localIP,
                    'Public Address': publicAddress || 'Not auto-detected',
                    'Connection String': connectionString || `Manual format: YOUR_PUBLIC_IP:${p2pPort}:${data.peerId}`,
                    'Share This': connectionString ? 'Copy the connection string above and share with others' : `Replace YOUR_PUBLIC_IP with actual public IP in: YOUR_PUBLIC_IP:${p2pPort}:${data.peerId}`,
                    'Local Addresses': data.localAddresses || [],
                    'NAT Status': data.isPublicNode ? 'Public (can accept connections)' : 'Behind NAT (needs relay)',
                    'Important': 'Use P2P port for connections, NOT the web interface port!'
                };
                
                showStatus('discoveryStatus', 
                    data.isPublicNode 
                        ? '‚úÖ Connection info ready for sharing' 
                        : '‚ö†Ô∏è Node behind NAT - direct connections not possible', 
                    !data.isPublicNode);
                showResult('discoveryResult', connectionInfo);
                
                // Auto-select connection string for easy copying
                if (connectionString && document.getElementById('connectionStringInput')) {
                    document.getElementById('connectionStringInput').value = connectionString;
                }
                
            } catch (error) {
                showStatus('discoveryStatus', 'Error getting connection info: ' + error.message, true);
            }
        }

        async function getDetailedPeerInfo() {
            try {
                const response = await fetch('/api/info');
                const data = await response.json();
                
                if (data.connectedPeerInfo && Object.keys(data.connectedPeerInfo).length > 0) {
                    const peerCount = Object.keys(data.connectedPeerInfo).length;
                    const publicNode = data.isPublicNode;
                    
                    showStatus('peerInfoStatus', 
                        `üìä ${peerCount} detailed peer record${peerCount === 1 ? '' : 's'} ${publicNode ? '(stored for relay assistance)' : ''}`, 
                        false);
                    
                    // Format peer information for better display
                    const formattedPeerInfo = {};
                    for (const [peerId, info] of Object.entries(data.connectedPeerInfo)) {
                        const shortId = peerId.substring(0, 12) + '...';
                        formattedPeerInfo[shortId] = {
                            'Full ID': info.id,
                            'Connection Type': info.connection_type || 'unknown',
                            'Addresses': info.addresses || [],
                            'First Seen': new Date(info.first_seen).toLocaleString(),
                            'Last Seen': new Date(info.last_seen).toLocaleString(),
                            'Validated': info.is_validated ? 'Yes' : 'No'
                        };
                    }
                    
                    showResult('detailedPeerInfo', formattedPeerInfo);
                } else {
                    showStatus('peerInfoStatus', 'üì≠ No detailed peer information available', true);
                    document.getElementById('detailedPeerInfo').textContent = '';
                }
            } catch (error) {
                showStatus('peerInfoStatus', 'Error getting detailed peer info: ' + error.message, true);
            }
        }

        // Auto-refresh node info and monitor status
        function startAutoRefresh() {
            getNodeInfo();
            getMonitorStatus();
            getDetailedPeerInfo();
            
            // Auto-refresh every 5 seconds
            setInterval(() => {
                getNodeInfo();
                getMonitorStatus();
                getDetailedPeerInfo();
            }, 5000);
        }

        // Load initial data
        window.onload = function() {
            startAutoRefresh();
        };
    </script>
</body>
</html>