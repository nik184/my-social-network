<!DOCTYPE html>
<html>
<head>
    <title>Distributed Social Network</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background-color: #f5f5f5; }
        .container { max-width: 800px; margin: 0 auto; background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .header { text-align: center; color: #333; margin-bottom: 30px; position: relative; }
        .section { margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 5px; }
        .button { background-color: #007bff; color: white; padding: 10px 15px; border: none; border-radius: 5px; cursor: pointer; margin: 5px; }
        .button:hover { background-color: #0056b3; }
        .input { padding: 8px; margin: 5px; border: 1px solid #ddd; border-radius: 3px; width: 200px; }
        .result { background-color: #f8f9fa; padding: 10px; margin: 10px 0; border-radius: 3px; font-family: monospace; white-space: pre-wrap; }
        .status { padding: 10px; margin: 10px 0; border-radius: 3px; }
        .success { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .error { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        
        /* Avatar styles */
        .avatar-container { position: absolute; top: 10px; right: 10px; }
        .avatar { width: 60px; height: 60px; border-radius: 50%; object-fit: cover; cursor: pointer; border: 3px solid #007bff; transition: transform 0.2s; }
        .avatar:hover { transform: scale(1.1); }
        .avatar-placeholder { width: 60px; height: 60px; border-radius: 50%; background: #e9ecef; display: flex; align-items: center; justify-content: center; color: #6c757d; font-size: 24px; cursor: pointer; border: 3px solid #dee2e6; }
        
        /* Gallery modal styles */
        .gallery-modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.9); }
        .gallery-content { position: relative; margin: auto; padding: 0; width: 90%; max-width: 800px; height: 100%; display: flex; align-items: center; justify-content: center; flex-direction: column; }
        .gallery-image { max-width: 100%; max-height: 80vh; object-fit: contain; }
        .gallery-nav { position: absolute; top: 50%; transform: translateY(-50%); background: rgba(255,255,255,0.8); border: none; font-size: 24px; padding: 10px 15px; cursor: pointer; border-radius: 5px; }
        .gallery-nav:hover { background: rgba(255,255,255,1); }
        .gallery-prev { left: 20px; }
        .gallery-next { right: 20px; }
        .gallery-close { position: absolute; top: 20px; right: 30px; color: white; font-size: 40px; font-weight: bold; cursor: pointer; }
        .gallery-close:hover { color: #ccc; }
        .gallery-counter { color: white; text-align: center; margin-top: 20px; font-size: 18px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="avatar-container">
                <div id="avatarDisplay" class="avatar-placeholder" onclick="openGallery()">üë§</div>
            </div>
            <h1>üåê Distributed Social Network</h1>
            <p>Manage and share your space184 directory using libp2p peer-to-peer networking</p>
            <p style="font-size: 0.9em; color: #666;">‚ú® Features: DHT discovery, NAT traversal, hole punching, auto file monitoring</p>
        </div>
        
        <div class="section">
            <h3>üìÅ Directory Management</h3>
            <button class="button" onclick="createDirectory()">Create space184 Directory</button>
            <button class="button" onclick="scanDirectory()">Manual Scan</button>
            <button class="button" onclick="getMonitorStatus()">Monitor Status</button>
            <div id="directoryStatus"></div>
            <div id="monitorStatus" class="status" style="margin: 10px 0;"></div>
            <div id="directoryInfo" class="result"></div>
        </div>
        
        <div class="section">
            <h3>üîç P2P Network Discovery</h3>
            <div style="margin-bottom: 15px;">
                <h4>üîó Connect by Peer ID (Local Network)</h4>
                <input type="text" id="peerIdInput" class="input" placeholder="Enter Peer ID" style="width: 400px;">
                <button class="button" onclick="discoverPeer()">Discover Peer</button>
            </div>
            <div style="margin-bottom: 15px;">
                <h4>üåê Connect by IP Address (Internet)</h4>
                <input type="text" id="ipInput" class="input" placeholder="IP Address (e.g., 203.0.113.1)" style="width: 150px;">
                <input type="text" id="portInput" class="input" placeholder="Port (e.g., 9001)" style="width: 100px;">
                <input type="text" id="targetPeerIdInput" class="input" placeholder="Target Peer ID" style="width: 300px;">
                <button class="button" onclick="connectByIP()">Connect by IP</button>
            </div>
            <div style="margin-bottom: 15px;">
                <h4>üìã Connection String</h4>
                <input type="text" id="connectionStringInput" class="input" placeholder="Paste connection string (IP:PORT:PEER_ID)" style="width: 500px;">
                <button class="button" onclick="connectByString()">Connect</button>
            </div>
            <button class="button" onclick="getConnectedPeers()">Show Connected Peers</button>
            <button class="button" onclick="getConnectionInfo()">Get My Connection Info</button>
            <div id="discoveryStatus"></div>
            <div id="discoveryResult" class="result"></div>
        </div>
        
        <div class="section">
            <h3>‚ÑπÔ∏è Current Node Info</h3>
            <button class="button" onclick="getNodeInfo()">Refresh Info</button>
            <div id="natStatus" class="status" style="margin: 10px 0;"></div>
            <div id="nodeInfo" class="result"></div>
        </div>
        
        <div class="section">
            <h3>üë• Connected Peer Details</h3>
            <button class="button" onclick="getDetailedPeerInfo()">Show Detailed Peer Info</button>
            <div id="peerInfoStatus" class="status" style="margin: 10px 0;"></div>
            <div id="detailedPeerInfo" class="result"></div>
        </div>
        
        <div class="section">
            <h3>üìú Connection History</h3>
            <button class="button" onclick="getConnectionHistory()">Refresh History</button>
            <div id="connectionHistoryStatus" class="status" style="margin: 10px 0;"></div>
            <div id="connectionHistory" style="margin: 10px 0;"></div>
        </div>
        
        <div class="section">
            <h3>üîó Second-Degree Connections</h3>
            <p style="font-size: 0.9em; color: #666;">Peers connected to your direct connections (friends of friends)</p>
            <button class="button" onclick="getSecondDegreeConnections()">Discover Peers</button>
            <div id="secondDegreeStatus" class="status" style="margin: 10px 0;"></div>
            <div id="secondDegreeConnections" style="margin: 10px 0;"></div>
        </div>
    </div>

    <!-- Avatar Gallery Modal -->
    <div id="galleryModal" class="gallery-modal">
        <div class="gallery-content">
            <span class="gallery-close" onclick="closeGallery()">&times;</span>
            <button class="gallery-nav gallery-prev" onclick="previousImage()">&#10094;</button>
            <img id="galleryImage" class="gallery-image" src="" alt="Avatar">
            <button class="gallery-nav gallery-next" onclick="nextImage()">&#10095;</button>
            <div class="gallery-counter">
                <span id="currentImageIndex">1</span> / <span id="totalImages">1</span>
            </div>
        </div>
    </div>

    <script>
        function showStatus(elementId, message, isError = false) {
            const element = document.getElementById(elementId);
            element.innerHTML = message;
            element.className = 'status ' + (isError ? 'error' : 'success');
        }

        function showResult(elementId, data) {
            document.getElementById(elementId).textContent = JSON.stringify(data, null, 2);
        }

        // Avatar-related variables
        let avatarImages = [];
        let currentImageIndex = 0;

        // Load avatar images
        async function loadAvatarImages() {
            try {
                const response = await fetch('/api/avatar');
                const data = await response.json();
                
                avatarImages = data.images || [];
                
                if (avatarImages.length > 0) {
                    // Display the primary avatar (first image)
                    const avatarDisplay = document.getElementById('avatarDisplay');
                    avatarDisplay.innerHTML = `<img src="/api/avatar/${avatarImages[0]}" alt="Avatar" class="avatar">`;
                } else {
                    // Keep the placeholder if no images
                    const avatarDisplay = document.getElementById('avatarDisplay');
                    avatarDisplay.innerHTML = 'üë§';
                    avatarDisplay.className = 'avatar-placeholder';
                }
            } catch (error) {
                console.log('No avatar images found or error loading:', error.message);
            }
        }

        // Open gallery modal
        function openGallery() {
            if (avatarImages.length === 0) {
                // If no images, try to create the avatar directory
                createAvatarDirectory();
                return;
            }
            
            currentImageIndex = 0;
            showGalleryImage();
            document.getElementById('galleryModal').style.display = 'block';
            updateGalleryCounter();
        }

        // Close gallery modal
        function closeGallery() {
            document.getElementById('galleryModal').style.display = 'none';
        }

        // Show current gallery image
        function showGalleryImage() {
            if (avatarImages.length > 0) {
                const galleryImage = document.getElementById('galleryImage');
                galleryImage.src = `/api/avatar/${avatarImages[currentImageIndex]}`;
            }
        }

        // Navigate to previous image
        function previousImage() {
            if (avatarImages.length > 1) {
                currentImageIndex = (currentImageIndex - 1 + avatarImages.length) % avatarImages.length;
                showGalleryImage();
                updateGalleryCounter();
            }
        }

        // Navigate to next image
        function nextImage() {
            if (avatarImages.length > 1) {
                currentImageIndex = (currentImageIndex + 1) % avatarImages.length;
                showGalleryImage();
                updateGalleryCounter();
            }
        }

        // Update gallery counter
        function updateGalleryCounter() {
            document.getElementById('currentImageIndex').textContent = currentImageIndex + 1;
            document.getElementById('totalImages').textContent = avatarImages.length;
            
            // Hide navigation arrows if only one image
            const prevBtn = document.querySelector('.gallery-prev');
            const nextBtn = document.querySelector('.gallery-next');
            if (avatarImages.length <= 1) {
                prevBtn.style.display = 'none';
                nextBtn.style.display = 'none';
            } else {
                prevBtn.style.display = 'block';
                nextBtn.style.display = 'block';
            }
        }

        // Create avatar directory and show instructions
        async function createAvatarDirectory() {
            try {
                // First ensure space184 directory exists
                await fetch('/api/create', { method: 'POST' });
                
                alert('Avatar directory is ready!\n\nTo add your avatar:\n1. Navigate to your space184/images/avatar folder\n2. Place one or more image files (jpg, png, gif, etc.)\n3. Refresh this page\n\nThe first image will become your avatar, and you can browse all images by clicking on it.');
            } catch (error) {
                alert('Error creating avatar directory: ' + error.message);
            }
        }

        // Load peer avatar images and return primary avatar info
        async function getPeerAvatar(peerID) {
            try {
                const response = await fetch(`/api/peer-avatar/${peerID}`);
                if (!response.ok) {
                    return null;
                }
                const data = await response.json();
                if (data.images && data.images.length > 0) {
                    return {
                        hasAvatar: true,
                        primary: data.primary || data.images[0],
                        count: data.count,
                        url: `/api/peer-avatar/${peerID}/${data.primary || data.images[0]}`
                    };
                }
                return null;
            } catch (error) {
                return null;
            }
        }

        // Create avatar HTML element for peer
        function createPeerAvatarElement(peerID, avatarInfo, size = '32px') {
            if (avatarInfo && avatarInfo.hasAvatar) {
                return `<img src="${avatarInfo.url}" alt="Avatar" style="width: ${size}; height: ${size}; border-radius: 50%; object-fit: cover; margin-right: 10px; border: 2px solid #ddd;" />`;
            } else {
                return `<div style="width: ${size}; height: ${size}; border-radius: 50%; background: #e9ecef; display: flex; align-items: center; justify-content: center; margin-right: 10px; border: 2px solid #ddd; font-size: 16px;">üë§</div>`;
            }
        }

        // Close modal when clicking outside the image
        window.onclick = function(event) {
            const modal = document.getElementById('galleryModal');
            if (event.target === modal) {
                closeGallery();
            }
        }

        // Keyboard navigation for gallery
        document.addEventListener('keydown', function(event) {
            const modal = document.getElementById('galleryModal');
            if (modal.style.display === 'block') {
                if (event.key === 'ArrowLeft') {
                    previousImage();
                } else if (event.key === 'ArrowRight') {
                    nextImage();
                } else if (event.key === 'Escape') {
                    closeGallery();
                }
            }
        });

        async function createDirectory() {
            try {
                const response = await fetch('/api/create', { method: 'POST' });
                const data = await response.json();
                showStatus('directoryStatus', 'Directory created successfully!');
            } catch (error) {
                showStatus('directoryStatus', 'Error creating directory: ' + error.message, true);
            }
        }

        async function scanDirectory() {
            try {
                const response = await fetch('/api/scan', { method: 'POST' });
                const data = await response.json();
                showStatus('directoryStatus', 'Manual scan completed successfully!');
                getNodeInfo(); // Refresh the info
            } catch (error) {
                showStatus('directoryStatus', 'Error scanning directory: ' + error.message, true);
            }
        }

        async function getMonitorStatus() {
            try {
                const response = await fetch('/api/monitor');
                const data = await response.json();
                
                if (data.monitoring) {
                    const lastScan = data.lastScan ? new Date(data.lastScan).toLocaleTimeString() : 'Never';
                    showStatus('monitorStatus', `üì° Auto-monitoring active | Last scan: ${lastScan}`, false);
                } else {
                    showStatus('monitorStatus', '‚ùå Auto-monitoring inactive', true);
                }
            } catch (error) {
                showStatus('monitorStatus', 'Error getting monitor status: ' + error.message, true);
            }
        }

        async function discoverPeer() {
            const peerId = document.getElementById('peerIdInput').value;
            if (!peerId) {
                showStatus('discoveryStatus', 'Please enter a Peer ID', true);
                return;
            }

            try {
                const response = await fetch('/api/discover', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ peerId: peerId })
                });
                
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                
                const data = await response.json();
                showStatus('discoveryStatus', 'Peer discovered successfully!');
                showResult('discoveryResult', data);
            } catch (error) {
                showStatus('discoveryStatus', 'Error discovering peer: ' + error.message, true);
                document.getElementById('discoveryResult').textContent = '';
            }
        }

        async function getConnectedPeers() {
            try {
                const response = await fetch('/api/peers');
                const data = await response.json();
                
                const validatedCount = data.validatedCount || data.count || 0;
                const totalCount = data.totalConnectedCount || 0;
                
                if (totalCount > validatedCount) {
                    showStatus('discoveryStatus', `‚úÖ ${validatedCount} app peers | üîó ${totalCount} total connections`, false);
                } else {
                    showStatus('discoveryStatus', `‚úÖ Connected to ${validatedCount} app peers`, false);
                }
                
                // Show detailed information
                const peerInfo = {
                    'Application Peers (Validated)': data.validatedPeers || data.peers || [],
                    'Validated Count': validatedCount,
                    'Total Connections': totalCount,
                    'Filtering': totalCount > validatedCount ? 'Active - Non-app peers filtered out' : 'No non-app peers detected'
                };
                
                showResult('discoveryResult', peerInfo);
            } catch (error) {
                showStatus('discoveryStatus', 'Error getting peers: ' + error.message, true);
            }
        }

        async function getNodeInfo() {
            try {
                const response = await fetch('/api/info');
                const data = await response.json();
                
                // Display NAT status
                if (data.isPublicNode !== undefined) {
                    const natStatusMsg = data.isPublicNode 
                        ? 'üåê PUBLIC NODE - Can assist with NAT traversal' 
                        : 'üè† NAT\'d NODE - Seeks assistance for connections';
                    showStatus('natStatus', natStatusMsg, !data.isPublicNode);
                }
                
                // Create a clean display object
                const displayData = {
                    'Node ID': data.node?.id || 'Unknown',
                    'Addresses': data.node?.addresses || [],
                    'Last Seen': data.node?.lastSeen ? new Date(data.node.lastSeen).toLocaleString() : 'Unknown',
                    'NAT Status': data.isPublicNode ? 'Public (Can help others)' : 'Behind NAT (Needs assistance)',
                    'Directory Info': data.folderInfo || 'No directory scanned yet',
                    'Connected Peers': data.connectedPeerInfo ? Object.keys(data.connectedPeerInfo).length : 0
                };
                
                showResult('nodeInfo', displayData);
            } catch (error) {
                showStatus('nodeInfo', 'Error getting node info: ' + error.message, true);
            }
        }

        async function connectByIP() {
            const ip = document.getElementById('ipInput').value;
            const port = document.getElementById('portInput').value;
            const peerId = document.getElementById('targetPeerIdInput').value;
            
            if (!ip || !port || !peerId) {
                showStatus('discoveryStatus', 'Please enter IP address, port, and peer ID', true);
                return;
            }

            try {
                const response = await fetch('/api/connect-ip', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        ip: ip,
                        port: parseInt(port),
                        peerId: peerId 
                    })
                });
                
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                
                const data = await response.json();
                showStatus('discoveryStatus', 'Successfully connected via IP address!');
                showResult('discoveryResult', data);
            } catch (error) {
                showStatus('discoveryStatus', 'Error connecting by IP: ' + error.message, true);
                document.getElementById('discoveryResult').textContent = '';
            }
        }

        async function connectByString() {
            const connectionString = document.getElementById('connectionStringInput').value;
            
            if (!connectionString) {
                showStatus('discoveryStatus', 'Please enter a connection string', true);
                return;
            }

            // Parse connection string (format: IP:PORT:PEER_ID)
            const parts = connectionString.split(':');
            if (parts.length < 3) {
                showStatus('discoveryStatus', 'Invalid connection string format. Use IP:PORT:PEER_ID', true);
                return;
            }

            const ip = parts[0];
            const port = parts[1];
            const peerId = parts.slice(2).join(':'); // In case peer ID contains colons

            try {
                const response = await fetch('/api/connect-ip', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        ip: ip,
                        port: parseInt(port),
                        peerId: peerId 
                    })
                });
                
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                
                const data = await response.json();
                showStatus('discoveryStatus', 'Successfully connected using connection string!');
                showResult('discoveryResult', data);
            } catch (error) {
                showStatus('discoveryStatus', 'Error connecting by string: ' + error.message, true);
                document.getElementById('discoveryResult').textContent = '';
            }
        }

        async function getConnectionInfo() {
            try {
                const response = await fetch('/api/connection-info');
                const data = await response.json();
                
                // Create a shareable connection string
                let connectionString = '';
                let publicAddress = '';
                
                if (data.publicAddress && data.port && data.peerId) {
                    connectionString = `${data.publicAddress}:${data.port}:${data.peerId}`;
                    publicAddress = `${data.publicAddress}:${data.port}`;
                }
                
                // Extract P2P port from local addresses
                let p2pPort = 'Unknown';
                let localIP = 'Unknown';
                if (data.localAddresses && data.localAddresses.length > 0) {
                    for (const addr of data.localAddresses) {
                        if (addr.includes('/ip4/') && !addr.includes('127.0.0.1')) {
                            const parts = addr.split('/');
                            if (parts.length >= 5) {
                                localIP = parts[2];
                                p2pPort = parts[4];
                                break;
                            }
                        }
                    }
                }

                const connectionInfo = {
                    'Peer ID': data.peerId || 'Unknown',
                    'P2P Port': p2pPort + ' (Use this port for connections!)',
                    'Local IP': localIP,
                    'Public Address': publicAddress || 'Not auto-detected',
                    'Connection String': connectionString || `Manual format: YOUR_PUBLIC_IP:${p2pPort}:${data.peerId}`,
                    'Share This': connectionString ? 'Copy the connection string above and share with others' : `Replace YOUR_PUBLIC_IP with actual public IP in: YOUR_PUBLIC_IP:${p2pPort}:${data.peerId}`,
                    'Local Addresses': data.localAddresses || [],
                    'NAT Status': data.isPublicNode ? 'Public (can accept connections)' : 'Behind NAT (needs relay)',
                    'Important': 'Use P2P port for connections, NOT the web interface port!'
                };
                
                showStatus('discoveryStatus', 
                    data.isPublicNode 
                        ? '‚úÖ Connection info ready for sharing' 
                        : '‚ö†Ô∏è Node behind NAT - direct connections not possible', 
                    !data.isPublicNode);
                showResult('discoveryResult', connectionInfo);
                
                // Auto-select connection string for easy copying
                if (connectionString && document.getElementById('connectionStringInput')) {
                    document.getElementById('connectionStringInput').value = connectionString;
                }
                
            } catch (error) {
                showStatus('discoveryStatus', 'Error getting connection info: ' + error.message, true);
            }
        }

        async function getDetailedPeerInfo() {
            try {
                const response = await fetch('/api/info');
                const data = await response.json();
                
                if (data.connectedPeerInfo && Object.keys(data.connectedPeerInfo).length > 0) {
                    const peerCount = Object.keys(data.connectedPeerInfo).length;
                    const publicNode = data.isPublicNode;
                    
                    showStatus('peerInfoStatus', 
                        `üìä ${peerCount} detailed peer record${peerCount === 1 ? '' : 's'} ${publicNode ? '(stored for relay assistance)' : ''}`, 
                        false);
                    
                    // Format peer information for better display
                    const formattedPeerInfo = {};
                    for (const [peerId, info] of Object.entries(data.connectedPeerInfo)) {
                        const shortId = peerId.substring(0, 12) + '...';
                        const displayName = info.name && info.name !== '' && info.name !== 'unknown' 
                            ? info.name 
                            : 'Unknown';
                        const peerLabel = `${displayName} (${shortId})`;
                        
                        formattedPeerInfo[peerLabel] = {
                            'Name': displayName,
                            'Full ID': info.id,
                            'Connection Type': info.connection_type || 'unknown',
                            'Addresses': info.addresses || [],
                            'First Seen': new Date(info.first_seen).toLocaleString(),
                            'Last Seen': new Date(info.last_seen).toLocaleString(),
                            'Validated': info.is_validated ? 'Yes' : 'No'
                        };
                    }
                    
                    showResult('detailedPeerInfo', formattedPeerInfo);
                } else {
                    showStatus('peerInfoStatus', 'üì≠ No detailed peer information available', true);
                    document.getElementById('detailedPeerInfo').textContent = '';
                }
            } catch (error) {
                showStatus('peerInfoStatus', 'Error getting detailed peer info: ' + error.message, true);
            }
        }

        async function getConnectionHistory() {
            try {
                const response = await fetch('/api/connection-history');
                const data = await response.json();
                
                if (data.connections && data.connections.length > 0) {
                    showStatus('connectionHistoryStatus', `üìö Found ${data.connections.length} connection record${data.connections.length === 1 ? '' : 's'}`, false);
                    
                    // Create HTML for connection history with connect buttons
                    let historyHtml = '<div style="display: grid; gap: 10px;">';
                    
                    // Load avatars for all peers in parallel
                    const avatarPromises = data.connections.map(conn => getPeerAvatar(conn.peer_id));
                    const avatars = await Promise.all(avatarPromises);
                    
                    data.connections.forEach((conn, index) => {
                        const peerId = conn.peer_id;
                        const displayName = conn.peer_name && conn.peer_name !== '' && conn.peer_name !== 'unknown' 
                            ? conn.peer_name 
                            : 'Unknown';
                        const isCurrentlyConnected = conn.currently_connected || false;
                        const lastSeen = new Date(conn.last_connected).toLocaleString();
                        const avatarInfo = avatars[index];
                        const avatarHtml = createPeerAvatarElement(peerId, avatarInfo, '40px');
                        
                        historyHtml += `
                            <div style="border: 1px solid #ddd; border-radius: 5px; padding: 10px; background: ${isCurrentlyConnected ? '#d4edda' : '#f8f9fa'};">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <div style="display: flex; align-items: center;">
                                        ${avatarHtml}
                                        <div>
                                            <strong>${displayName}</strong> (${peerId})
                                            <br>
                                            <small style="color: #666;">
                                                Last connected: ${lastSeen}
                                                ${isCurrentlyConnected ? ' ‚Ä¢ <span style="color: #155724;">Currently connected</span>' : ''}
                                            </small>
                                        </div>
                                    </div>
                                    <div>
                                        ${!isCurrentlyConnected ? 
                                            `<button class="button" onclick="reconnectToPeer('${conn.peer_id}', '${conn.address}', '${displayName}')">Reconnect</button>` : 
                                            '<span style="color: #155724; font-weight: bold;">Connected ‚úì</span>'
                                        }
                                    </div>
                                </div>
                            </div>
                        `;
                    });
                    
                    historyHtml += '</div>';
                    document.getElementById('connectionHistory').innerHTML = historyHtml;
                } else {
                    showStatus('connectionHistoryStatus', 'üì≠ No connection history found', true);
                    document.getElementById('connectionHistory').innerHTML = '';
                }
            } catch (error) {
                showStatus('connectionHistoryStatus', 'Error getting connection history: ' + error.message, true);
                document.getElementById('connectionHistory').innerHTML = '';
            }
        }

        async function reconnectToPeer(peerId, address, displayName) {
            try {
                // Extract IP and port from address if it's in multiaddr format
                let ip = '';
                let port = '';
                
                if (address.includes('/ip4/')) {
                    const parts = address.split('/');
                    if (parts.length >= 5) {
                        ip = parts[2];
                        port = parts[4];
                    }
                } else {
                    // Try to parse as IP:PORT format
                    const parts = address.split(':');
                    if (parts.length >= 2) {
                        ip = parts[0];
                        port = parts[1];
                    }
                }
                
                if (!ip || !port) {
                    throw new Error('Could not extract IP and port from address: ' + address);
                }
                
                showStatus('connectionHistoryStatus', `üîÑ Reconnecting to ${displayName}...`, false);
                
                const response = await fetch('/api/connect-ip', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        ip: ip,
                        port: parseInt(port),
                        peerId: peerId 
                    })
                });
                
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                
                const data = await response.json();
                showStatus('connectionHistoryStatus', `‚úÖ Successfully reconnected to ${displayName}!`, false);
                
                // Refresh the connection history to update status
                setTimeout(() => {
                    getConnectionHistory();
                    getDetailedPeerInfo();
                }, 1000);
                
            } catch (error) {
                showStatus('connectionHistoryStatus', `‚ùå Failed to reconnect to ${displayName}: ${error.message}`, true);
            }
        }

        async function getSecondDegreeConnections() {
            try {
                showStatus('secondDegreeStatus', 'üîç Discovering second-degree connections...', false);
                
                const response = await fetch('/api/second-degree-peers');
                const data = await response.json();
                
                if (data.peers && data.peers.length > 0) {
                    showStatus('secondDegreeStatus', `üîó Found ${data.peers.length} second-degree peer${data.peers.length === 1 ? '' : 's'}`, false);
                    
                    // Create HTML for second-degree peers with connect buttons
                    let peersHtml = '<div style="display: grid; gap: 10px;">';
                    
                    // Load avatars for all peers in parallel
                    const avatarPromises = data.peers.map(peer => getPeerAvatar(peer.peer_id));
                    const avatars = await Promise.all(avatarPromises);
                    
                    data.peers.forEach((peer, index) => {
                        const shortId = peer.peer_id.substring(0, 12) + '...';
                        const displayName = peer.peer_name && peer.peer_name !== '' && peer.peer_name !== 'unknown' 
                            ? peer.peer_name 
                            : 'Unknown';
                        const connectionPath = peer.connection_path ? ` (via ${peer.connection_path})` : '';
                        const avatarInfo = avatars[index];
                        const avatarHtml = createPeerAvatarElement(peer.peer_id, avatarInfo, '40px');
                        
                        peersHtml += `
                            <div style="border: 1px solid #ddd; border-radius: 5px; padding: 10px; background: #f8f9fa;">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <div style="display: flex; align-items: center;">
                                        ${avatarHtml}
                                        <div>
                                            <strong>${displayName}</strong> (${shortId})
                                            <br>
                                            <small style="color: #666;">
                                                Connected via: ${peer.via_peer_name || 'Unknown'}${connectionPath}
                                                <br>
                                                Distance: 2 hops away
                                            </small>
                                        </div>
                                    </div>
                                    <div>
                                        <button class="button" onclick="connectToSecondDegreePeer('${peer.peer_id}', '${peer.via_peer_id}', '${displayName}')">Connect</button>
                                    </div>
                                </div>
                            </div>
                        `;
                    });
                    
                    peersHtml += '</div>';
                    document.getElementById('secondDegreeConnections').innerHTML = peersHtml;
                } else {
                    showStatus('secondDegreeStatus', 'üì≠ No second-degree connections found', true);
                    document.getElementById('secondDegreeConnections').innerHTML = '';
                }
            } catch (error) {
                showStatus('secondDegreeStatus', 'Error discovering second-degree connections: ' + error.message, true);
                document.getElementById('secondDegreeConnections').innerHTML = '';
            }
        }

        async function connectToSecondDegreePeer(targetPeerId, viaPeerId, displayName) {
            try {
                showStatus('secondDegreeStatus', `üîÑ Connecting to ${displayName} via hole punching...`, false);
                
                const response = await fetch('/api/connect-second-degree', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        targetPeerId: targetPeerId,
                        viaPeerId: viaPeerId
                    })
                });
                
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                
                const data = await response.json();
                showStatus('secondDegreeStatus', `‚úÖ Successfully connected to ${displayName}!`, false);
                
                // Refresh the lists to update connection status
                setTimeout(() => {
                    getSecondDegreeConnections();
                    getDetailedPeerInfo();
                }, 1000);
                
            } catch (error) {
                showStatus('secondDegreeStatus', `‚ùå Failed to connect to ${displayName}: ${error.message}`, true);
            }
        }

        // Auto-refresh node info and monitor status
        function startAutoRefresh() {
            loadAvatarImages();
            getNodeInfo();
            getMonitorStatus();
            getDetailedPeerInfo();
            getConnectionHistory();
            getSecondDegreeConnections();
            
            // Auto-refresh every 5 seconds
            setInterval(() => {
                loadAvatarImages();
                getNodeInfo();
                getMonitorStatus();
                getDetailedPeerInfo();
                getConnectionHistory();
                getSecondDegreeConnections();
            }, 5000);
        }

        // Load initial data
        window.onload = function() {
            startAutoRefresh();
        };
    </script>
</body>
</html>